
What is a BDD Framework?

Behavior-Driven Development (BDD) is an agile software development methodology that enhances collaboration between developers, testers, and non-technical stakeholders (like business analysts) to ensure that everyone shares a common understanding of how an application should behave. Here are some key points:
    
Focus on Behavior:
BDD emphasizes specifying the expected behavior of software using natural language. This makes requirements more accessible and understandable to all team members.

Collaboration:
It promotes close communication among team members, reducing the gap between technical implementation and business requirements.

Living Documentation:
By writing scenarios in plain language, the test cases serve as documentation that evolves with the application, ensuring that they always reflect the current state of the system.

Shift-Left Testing:
BDD encourages early testing during the development process, which helps in identifying issues sooner and ensures that the development aligns with business expectations.


####################################

How Does Cucumber Help Implement BDD?
Cucumber is a popular tool that facilitates the implementation of BDD by providing a structured yet flexible approach to writing and executing tests. Here’s how Cucumber supports BDD:
 
Gherkin Syntax:
Gherkin is a domain-specific language (DSL) designed specifically for Behavior-Driven Development (BDD). It enables writing test scenarios in a plain, structured, and human-readable format, bridging the gap between technical teams and non-technical stakeholders.

Feature Files:


These files contain scenarios that describe the expected behavior of the application using keywords makes it easy to understand what is being tested and why.




Keywords Summary :

#Feature: List of scenarios.
#Scenario: Business rule through list of steps with arguments.
#Given: Some precondition step
#When: Some key actions
#Then: To observe outcomes or validation
#And,But: To enumerate more Given,When,Then steps
#Scenario Outline: List of steps for data-driven as an Examples and <placeholder>
#Examples: Container for s table
#Background: List of steps run before each of the scenarios
#""" (Doc Strings)
#| (Data Tables)
#@ (Tags/Labels):To group Scenarios
#<> (placeholder)
#""
## (Comments)

Step Definitions:

Each line in a Gherkin scenario is linked to a corresponding code block (step definition). These methods, written in a programming language like Java, perform the actual testing actions (e.g., interacting with the application, verifying outcomes).

Integration with Testing Frameworks:
Cucumber integrates seamlessly with frameworks such as JUnit, TestNG (in Java) to run tests. This integration allows teams to leverage familiar testing tools while using a BDD approach.

Hooks for Pre/Post Conditions:
Cucumber provides hooks (e.g., @Before and @After) to run code before and after each scenario. This is useful for setup (like launching a browser) and teardown tasks (like taking screenshots or closing connections).

Living Documentation & Reporting:
Since scenarios are written in plain language, they double as documentation. Additionally, Cucumber’s reporting features (like JVM or HTML reports) help teams track test execution and quality metrics.



Reporting in Test Automation

Purpose:

Reporting is essential because it provides insights into test execution, showing what passed, what failed, and offering metrics that help assess the quality and stability of the application.

Cucumber Report Integration:

In a typical Cucumber setup, you configure your runner class (using @CucumberOptions) to specify report plugins (like HTML or JSON reports). These plugins are then used by Cucumber to generate detailed execution reports for your feature files.

1)JVM & HTML Reports:

The JVM report (with detailed logs and metrics) and the HTML report (with a user-friendly summary) are commonly generated by Cucumber’s reporting tools. They serve the purpose of summarizing the results of your BDD tests.

2)Report Builder Class & @AfterClass:

In many Cucumber projects, especially those that extend reporting capabilities, a dedicated Report Builder class is used to collate the results. The @AfterClass annotation ensures that report generation happens after all Cucumber scenarios have executed.




------------------------------------------------------------------------------

$$$Base Class

Definition:

A Base Class is a superclass that contains common methods, configurations, and utilities that are shared across different step definition classes. It centralizes functionalities like browser setup, teardown methods, and utility functions, ensuring that repetitive code is written only once.

Purpose:

Code Reusability: By placing shared functionalities in the Base Class, you avoid duplicating code across multiple classes.

Maintainability: Updates or changes (for example, a change in browser configuration) need to be made in just one place, simplifying maintenance.

Consistency: Ensures that all tests start with the same setup and configurations, leading to uniform behavior across the test suite.



static keyword
 
single memory reference - share the memory as single all the object reference across the project
inside the non static methods it allows all the members of the class (static variable , non-static variable, static method, non-static method) directly without the help of object reference.
inside the static method it allow to call only the static members(static variable and static method) without object reference



Cricket Analogy:

Imagine the Base Class as the standardized training regimen and game strategy shared by an entire cricket team.

Standardized Training: Just as every player follows the same training routines—like warming up, practicing specific drills, or using a common set of strategies—the Base Class provides a unified set of instructions (like launching the browser or configuring environment settings) that every test (or “player”) uses.

Uniform Game Strategy: The coach's playbook is shared among all players. No matter which player is on the field, they all adhere to the same tactics and guidelines. Similarly, the Base Class ensures that every test scenario starts on a level playing field with the same configurations and utilities.


###################################################################################

$$$Hooks

Hooks are special methods in Cucumber that execute at specific points during the test lifecycle. They help set up preconditions or perform cleanup actions without cluttering the step definitions.

@Before Hook

Purpose:

Execution Timing: Runs before each scenario.

Usage:

Initializes test prerequisites, such as launching a browser.
Sets up test data or configures the environment.
Prepares the system for the scenario that is about to run.


Hooks Implementation
Cucumber annotations - @Before -> Before annotation execute before executing each scenario - @After -> After annotation execute after each scenario

        - @BeforeStep - It will execute before each test step 
        - @AfterStep - It will execute after each test step


Execution flow with hooks annotations
  -> @Before
     -> Background keyword
      -> Scenario /Scenario Outline -> @BeforeStep -> @AfterStep
        -> @After

Steps to implement hooks annotations
  1. create a class as HooksImplementation under hooks package
  2. Declare two methods preCondition and postCondition with Hooks/cucumber annotations @Before and @After
  3. HooksImplementation should inherit ProjectSpecificMethod
  4. In the runner hooks package also include in glue attribute.


TestNG Implementation in Cucumber


Remove the Hooks annotations @Before and @After
In ProjectSpecificMethod Declare two methods precondition and postCondition with TestNG annotations @BeforeMethod and @AfterMethod
Runner class should inherit ProjectSpecificMethod
ProjectSpecificMethod should inherit AbstractTestNGCucumberTests

Cricket Analogy:

A)Think of the @Before hook as the pre-match warm-up and briefing session:

Pre-Match Warm-Up: Just as a cricket team warms up to get into the right physical and mental state before a match, the @Before hook sets up the necessary environment (like launching a browser or initializing data) before any test scenario starts.

Team Briefing: The coach gathers the team to review the game plan, ensuring everyone knows their role and responsibilities—similar to how the @Before hook ensures that all prerequisites are met before the scenario runs.

B)@After Hook

Purpose:

Execution Timing: Runs after each scenario.

Usage:

Performs cleanup tasks such as closing browser sessions.
Takes screenshots (especially useful when a test fails).
Resets test data or environment to a clean state for subsequent tests.

Cricket Analogy:

Imagine the @After hook as the post-match debrief and cleanup:

Post-Match Cool Down: After the match, players cool down, stretch, and review their performance. This is akin to the @After hook’s role in tidying up after a test scenario—closing sessions, collecting data (like screenshots), and resetting the state.

Debriefing Session: The coach holds a meeting to discuss what went well and what needs improvement, which parallels how the @After hook gathers results and cleans up, ensuring the next test (or match) starts fresh.

-----------------------------------------------------------
Summary
Each component in Cucumber BDD with Java is designed to promote clarity, reusability, and maintainability:

1)Maven and pom.xml manage your project and its dependencies.
2)The Test Runner Class (@CucumberOptions) links feature files to the underlying code.
3)Feature Files written in Gherkin offer a readable description of the test scenarios.
4)Step Definitions map these scenarios to executable code.
5)Hooks (@Before and @After) manage pre- and post-test actions.
6)Base ensure that common functions.
7)Report Generation captures and presents the results of test executions in both JVM and HTML formats, ensuring stakeholders have access to detailed test insights.
